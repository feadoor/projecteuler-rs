//! [Problem 103 (Special subset sums: optimum)](https://projecteuler.net/problem=103)
//!
//! # Solution detail
//!
//! There is a reasonably efficient method of iterating through all special sum sets, in increasing
//! order of their _average element_. It relies on three observations:
//!
//!
//!   1. Special sum sets can be generated by adding one element at a time, starting from the sets
//!      containing only two elements, and always adding elements in increasing order.
//!
//!   2. When adding a new element to an existing SSS, checking condition (i) can be done using
//!      a merge-sort-like algorithm on two lists - one of the set of sums in the original set,
//!      and one of the set of sums of the new set that include the new element.
//!
//!   3. When adding a new element, condition (ii) is equivalent to ensuring that the added element
//!      does not exceed a particular value which is easily calculated from the existing set.
//!
//! With these observations in mind, the way to generate all special sum sets in increasing order
//! of average element is:
//!
//!   1. Start with a priority queue (keyed by average element) of special sum sets, initially
//!      containing only the set {1, 2}.
//!
//!   2. Repeatedly pop the minimum element of the queue, and add its children to the queue, where
//!      the children are all SSS's that result from adding a single element to the current one.
//!
//!   3. An SSS of size 2 also has some "special" children - `{a, b} --> {a, b + 1}` and, if
//!      `b - a = 1` then also `{a, b} --> {a + 1, b + 1}`. This ensures all "starting" sets of size
//!      2 are considered.
//!
//! Because any child of an SSS has a strictly greater average than the original SSS, this ensures
//! that all SSS's are seen in increasing order of average, so to find an optimum SSS containing
//! 7 elements, just stop the iteration when the first 7-element set is found.

use std::cmp::Ordering;
use std::collections::BinaryHeap;

use projecteuler_rs::problem;

/// A structure representing a special sum set
struct SpecialSumSet {
    average: f64,
    elements: Vec<usize>,
    sums: Vec<usize>,
}

// Implement the ordering and equality traits to be able to use `SpecialSumSet` in a `BinaryHeap`.

impl PartialEq for SpecialSumSet {
    fn eq(&self, other: &Self) -> bool {
        self.average == other.average
    }
}

impl Eq for SpecialSumSet {}

impl PartialOrd for SpecialSumSet {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.average.partial_cmp(&other.average).map(|x| x.reverse())
    }
}

impl Ord for SpecialSumSet {
    fn cmp(&self, other: &Self) -> Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl SpecialSumSet {

    /// Create a new `SpecialSumSet` consisting of the given two elements.
    fn from_pair(a: usize, b: usize) -> SpecialSumSet {
        SpecialSumSet {
            average: (a + b) as f64 / 2.0,
            elements: vec![a, b],
            sums: vec![0, a, b, a + b],
        }
    }

    /// Attempt to add the given number to the `SpecialSumSet`, and if the result is also a
    /// `SpecialSumSet`, return it.
    fn with_additional_element(&self, n: usize) -> Option<SpecialSumSet> {
        let (mut ix, mut jx) = (0, 0);
        let length = self.sums.len();
        let mut new_sums = Vec::with_capacity(2 * length);

        while ix < length {
            match self.sums[ix].cmp(&(self.sums[jx] + n)) {
                Ordering::Equal => {
                    return None;
                },
                Ordering::Less => {
                    new_sums.push(self.sums[ix]);
                    ix += 1;
                },
                Ordering::Greater => {
                    new_sums.push(self.sums[jx] + n);
                    jx += 1;
                }
            }
        }

        while jx < length {
            new_sums.push(self.sums[jx] + n);
            jx += 1;
        }

        let new_average = (self.average * (length as f64) + n as f64) / (length as f64 + 1.0);
        let mut new_elements = self.elements.clone();
        new_elements.push(n);

        Some(SpecialSumSet{
            average: new_average,
            elements: new_elements,
            sums: new_sums,
        })
    }

    /// Return an upper bound for the next element that can be added to this `SpecialSumSet` without
    /// violating condition (ii).
    ///
    /// length = 2: [a, b]                -->    n < a + b
    /// length = 3: [a, b, c]             -->    n < a + b
    /// length = 4: [a, b, c, d]          -->    n < a + b + c - d
    /// length = 5: [a, b, c, d, e]       -->    n < a + b + c - e
    /// length = 6: [a, b, c, d, e, f]    -->    n < a + b + c + d - e - f
    fn next_element_upper_bound(&self) -> usize {
        let length = self.elements.len();
        let addend: usize = self.elements[..length / 2 + 1].iter().sum();
        let minuend: usize = self.elements[(length + 3) / 2..].iter().sum();
        addend - minuend
    }
}

/// A structure capable of iterating over `SpecialSumSet`s using a priority queue.
struct SpecialSumSetIterator {
    priority_q: BinaryHeap<SpecialSumSet>,
}

impl SpecialSumSetIterator {

    fn new() -> Self {
        let mut q = BinaryHeap::new();
        q.push(SpecialSumSet::from_pair(1, 2));
        SpecialSumSetIterator { priority_q: q }
    }

    fn children_of_pair(set: &SpecialSumSet) -> Vec<SpecialSumSet> {
        let (a, b) = (set.elements[0], set.elements[1]);
        if a + 1 == b {
            vec![SpecialSumSet::from_pair(a, b + 1), SpecialSumSet::from_pair(a + 1, b + 1)]
        } else {
            vec![SpecialSumSet::from_pair(a, b + 1)]
        }
    }

    fn children<'a>(set: &'a SpecialSumSet) -> impl Iterator<Item = SpecialSumSet> + 'a {
        let (start, end) = (set.elements.last().unwrap() + 1, set.next_element_upper_bound());
        (start..end).filter_map(move |n| set.with_additional_element(n))
    }
}

impl Iterator for SpecialSumSetIterator {
    type Item = SpecialSumSet;

    fn next(&mut self) -> Option<Self::Item> {
        self.priority_q.pop().map(|set| {
            if set.elements.len() == 2 {
                for child in SpecialSumSetIterator::children_of_pair(&set) {
                    self.priority_q.push(child);
                }
            }
            for child in SpecialSumSetIterator::children(&set) {
                self.priority_q.push(child);
            }
            set
        })
    }
}

/// Find an optimum special sum set containing the given number of elements.
fn solve(size: usize) -> Vec<usize> {
    SpecialSumSetIterator::new().find(|set| set.elements.len() == size).unwrap().elements
}

/// Solve the problem, returning the answer as a `String`
fn answer() -> String {
    solve(7).iter().map(|n| n.to_string()).collect()
}

problem!(answer, "20313839404245");
