//! [Problem 58 (Spiral primes)](https://projecteuler.net/problem=58)
//!
//! # Solution detail
//!
//! The numbers along each diagonal are generated by a particular quadratic expression. These
//! expressions are, for n = 0, 1, 2...
//!
//! - **Bottom-right**: (2n + 1)<sup>2</sup>
//! - **Bottom-left**: (2n + 1)<sup>2</sup> - 2n
//! - **Top-left**: (2n + 1)<sup>2</sup> - 4n
//! - **Top-right**: (2n + 1)<sup>2</sup> - 6n
//!
//! So we can simply generate the terms in these quadratic sequences, check them for primality, and
//! keep track of the ratio of prime terms as we go. To do primality checks, it is convenient to
//! have a precomputed prime sieve. If it turns out that the sieve is not large enough, then we can
//! increase the size as we go.

use primesieve::Sieve;
use projecteuler_rs::problem;

/// Check if the given number is prime using the given prime sieve, expanding the size of the prime
/// sieve if necessary.
fn is_prime_safe(n: u64, sieve: &mut Sieve) -> bool {
    loop {
        match sieve.is_prime(n) {
            Ok(x) => return x,
            Err(_) => *sieve = Sieve::to_limit(2 * sieve.limit()),
        }
    }
}

/// Find how many layers of a spiral grid must be generated before the ratio of primes on the
/// diagonals falls below 10% for the first time.
fn solve() -> u64 {
    // Create a sieve to use for primality testing.
    let mut sieve = Sieve::to_limit(10_000);

    // Keep track of the size of the spiral grid, the number of terms on the diagonals, and the
    // amount of these terms which are primes. Start with a grid of size 3.
    let (mut size, mut terms, mut primes) = (2, 5, 3);
    while terms <= 10 * primes {

        // Calculate the number of new terms which are prime.
        let br_term = 4 * size * (size + 1) + 1;
        for &term in &[br_term, br_term - 2 * size, br_term - 4 * size, br_term - 6 * size] {
            if is_prime_safe(term, &mut sieve) {
                primes += 1;
            }
        }

        // Update the size and the overall number of terms.
        size += 1;
        terms += 4;
    }

    2 * size - 1
}

/// Solve the problem, returning the answer as a `String`
fn answer() -> String {
    solve().to_string()
}

problem!(answer, "26241");
