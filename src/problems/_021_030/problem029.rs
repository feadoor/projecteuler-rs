//! [Problem 29 (Distinct powers)](https://projecteuler.net/problem=29)
//!
//! # Problem statement
//!
//! Consider all integer combinations of a<sup>b</sup> for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
//!
//! 2<sup>2</sup>=4, 2<sup>3</sup>=8, 2<sup>4</sup>=16, 2<sup>5</sup>=32<br>
//! 3<sup>2</sup>=9, 3<sup>3</sup>=27, 3<sup>4</sup>=81, 3<sup>5</sup>=243<br>
//! 4<sup>2</sup>=16, 4<sup>3</sup>=64, 4<sup>4</sup>=256, 4<sup>5</sup>=1024<br>
//! 5<sup>2</sup>=25, 5<sup>3</sup>=125, 5<sup>4</sup>=625, 5<sup>5</sup>=3125
//!
//! If they are then placed in numerical order, with any repeats removed, we get the following
//! sequence of 15 distinct terms:
//!
//! 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
//!
//! How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
//!
//! # Solution detail
//!
//! We can determine the total number of distinct terms without needing to calculate the actual
//! results - by instead calculating the prime factorisations of the results.
//!
//! For each pair of `a` and `b`, compute the prime factorisation of `a`, multiply each exponent
//! by `b`, and store the result in a `HashSet`. The number of elements in the `HashSet` at the
//! end of it all is the answer.

#[macro_use]
extern crate projecteuler_rs;
extern crate itertools;
extern crate number_theory;
extern crate primesieve;

use std::collections::HashSet;
use itertools::Itertools;
use number_theory::integer_sqrt;
use primesieve::Sieve;

/// Find the number of distinct values a^b for 2 ≤ a ≤ `a_lim` and 2 ≤ b ≤ `b_lim`.
fn solve(a_lim: u64, b_lim: u64) -> usize {
    // Somewhere to store the factorisations of the results.
    let mut results = HashSet::<Vec<(u64, u64)>>::new();

    // Sieve for enough primes to be able to factorise each possible value of a.
    let sieve = Sieve::to_limit(integer_sqrt(a_lim));

    // Map each pair of a and b to the prime factorisation of a, b
    let result_factors = (2..a_lim + 1)
        .map(|a| sieve.factorise(a).unwrap())
        .cartesian_product(2..b_lim + 1)
        .map(|(factors, b)| factors.iter().map(|&(base, exp)| (base, b * exp)).collect());

    // Store all the factorisations in the HashSet and return its size
    for factors in result_factors {
        results.insert(factors);
    }
    results.len()
}

/// Solve the problem, returning the answer as a `String`
fn answer() -> String {
    solve(100, 100).to_string()
}

problem!(answer, "9183");
